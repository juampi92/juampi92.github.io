<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Juampi&#039;s Blog</title>
    <link href="https://barreto.jp/" />
    <link type="application/atom+xml" rel="self" href="https://barreto.jp/blog/feed.atom" />
    <updated>2023-05-16T21:31:34+00:00</updated>
    <id>https://barreto.jp/blog/feed.atom</id>
    <author>
        <name>Juan Pablo Barreto</name>
    </author>
                <entry>
    <id>https://barreto.jp/blog/chatgpt-plugin-with-laravel/</id>
    <link type="text/html" rel="alternate" href="https://barreto.jp/blog/chatgpt-plugin-with-laravel/" />
    <title>ChatGPT Plugin with Laravel</title>
    <published>2023-05-16T00:00:00+00:00</published>
    <updated>2023-05-16T00:00:00+00:00</updated>
    <author>
        <name>Juan Pablo Barreto</name>
    </author>
    <summary type="html">Tutorial on building your first ChatGPT plugin with Laravel step by step.</summary>
    <content type="html"><![CDATA[
        <p>Starting last week (May 12), OpenAI <a href="https://help.openai.com/en/articles/6825453-chatgpt-release-notes#h_9894d7b0a4" target="_blank">rolled out</a> the plugins for ChatGPT plus users. This means that we can not only use the plugins from their store but also create our own plugins.</p>

<p>In this article, we will go through the process of creating a plugin for ChatGPT using Laravel.
The plugin will be a very simple web browser that will fetch the HTML content of a given URL, but this concept can be applied to any other use case.</p>

<p>Why a browser? Because it's a simple example.</p>

<p><strong>TL;DR:</strong> The code is available at <a href="https://github.com/juampi92/chatgpt-plugin-in-laravel" target="_blank">github.com/juampi92/chatgpt-plugin-in-laravel</a>.</p>

<h2>Step 0 - Setup</h2>

<p>Start by creating a new laravel project</p>

<pre><code>composer create-project laravel/laravel chatgpt-browse-plugin
composer require guzzlehttp/guzzle
</code></pre>

<p>We will need the <code>guzzlehttp/guzzle</code> package to make HTTP requests using the <a href="https://laravel.com/docs/http-client" target="_blank">Laravel HTTP Client</a>.</p>

<h2>Step 1 - Plugin configuration</h2>

<p>ChatGPT requires us to have a plugin manifesto. This file is a JSON file that contains information about the plugin, such as the name, description, logo, etc.
We will need to locate it in the following URL <code>localhost:8000/.well-known/ai-plugin.json</code>.</p>

<p>For reasons that will be explained later, we will create the file inside <code>resources/</code> instead of <code>public</code>.</p>

<pre><code>mkdir resources/.well-known
touch resources/.well-known/ai-plugin.json
</code></pre>

<pre><code class="language-json">{
    "schema_version": "v1",
    "name_for_human": "My Local Web Browser Plugin",
    "name_for_model": "MyLocalWebBrowser",
    "description_for_human": "Plugin for browsing the web locally in the name of ChatGPT.",
    "description_for_model": "Plugin for browsing websites locally and getting their content.",
    "auth": {
        "type": "none"
    },
    "api": {
        "type": "openapi",
        "url": "http://localhost:8000/openapi.yaml",
        "is_user_authenticated": false
    },
    "logo_url": "http://localhost:8000/logo.png",
    "contact_email": "support@example.com",
    "legal_info_url": "http://www.example.com/legal"
}
</code></pre>

<p><strong>Notes:</strong></p>

<ul>
<li>If you decide to use a different <strong>port</strong>, make sure to update the <code>url</code> fields (api.url and logo_url).</li>
<li>Also, if you decide to use a different name, make sure <code>name_for_model</code> doesn't have any spaces.</li>
</ul>

<p>To make the file available to the public, we need to do two things:</p>

<ol>
<li>Update the routes in <code>routes/web.php</code>:</li>
</ol>

<pre><code class="language-php">Route::get('.well-known/ai-plugin.json', fn () =&gt;
    File::get(resource_path('.well-known/ai-plugin.json')));
</code></pre>

<ol start="2">
<li>Update <code>config/cors.php</code> to have <code>'paths' =&gt; ['*'],</code>.</li>
</ol>

<p>The reason why we can't use the <code>/public</code> directory is because
the plugin will be hosted on a different domain and the browser
will block the request due to CORS.
If you intend to host the plugin on a server, you can use
the <code>/public</code> directory and configure apache/nginx to allow
CORS on static files.</p>

<h2>Step 2 - Making it browse</h2>

<p>Now we need to create the API that will be used by ChatGPT to browse the web.</p>

<p>Let's create a new controller:</p>

<pre><code>php artisan make:controller BrowseController
</code></pre>

<p>And the content of the controller should look something like this:</p>

<pre><code class="language-php">use Illuminate\Support\Facades\Http;

public function __invoke(Request $request): JsonResponse
{
    ['url' =&gt; $url] = $request-&gt;validate([
        'url' =&gt; 'required|url',
    ]);

    $response = Http::withHeaders([
            'User-Agent' =&gt; 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36',
        ])
            -&gt;get($url);

    return new JsonResponse([
        'response' =&gt; $response-&gt;body(),
    ]);
}
</code></pre>

<p>Add the controller to <code>routes/api.php</code>:</p>

<pre><code class="language-php">Route::get('/browse', BrowseController::class);
</code></pre>

<h2>Step 3 - API Documentation</h2>

<p>In order for ChatGPT to understand how to use our plugin,
we need to generate an <a href="https://spec.openapis.org/oas/v3.1.0" target="_blank">OpenAPI specification</a>.
GPT will read the specification and decide when and how to use your endpoints,
so it's important that the API is clear.</p>

<p>To generate the actual yaml file, we will use the <code>zircote/swagger-php</code> package.</p>

<pre><code class="language-php">composer require zircote/swagger-php --dev
</code></pre>

<p>Now we need to update the Controller using the OpenApi Annotations:</p>

<pre><code class="language-php">/**
 * @OA\Info(title="MyLocalWebBrowserAPI", version="0.1")
 */
class BrowseController extends Controller
{
    /**
     * @OA\Get(
     *     path="/api/browse",
     *     summary="Get HTML content of an URL",
     *     @OA\Parameter(
     *         name="url",
     *         in="query",
     *         description="URL to fetch the HTML from",
     *         required=true,
     *         @OA\Schema(
     *             type="string",
     *             example="http://example.com"
     *         )
     *     ),
     *     @OA\Response(
     *         response=200,
     *         description="HTML content of the URL",
     *         @OA\JsonContent(
     *            type="object",
     *            required={"response"},
     *            @OA\Property(
     *              property="response",
     *              type="string",
     *              description="Raw HTML content of the URL"
     *           )
     *         )
     *     )
     * )
     */
</code></pre>

<p>To generate our OpenAPI specification, we run the following:</p>

<pre><code class="language-bash">./vendor/bin/openapi app -o resources/openapi.yaml
</code></pre>

<p>And, for the same reasons mentioned before, add
the following route to <code>routes/web.php</code>:</p>

<pre><code class="language-php">Route::get('openapi.yaml', fn () =&gt;
    File::get(resource_path('openapi.yaml')));
</code></pre>

<h2>Step 4 - Serving</h2>

<p>To run our plugin, simply call</p>

<pre><code class="language-bash">php artisan serve --port=8000
</code></pre>

<h2>Step 5 - Installing the plugin</h2>

<p>Now that we have our plugin ready, we need to install it in ChatGPT.
When creating a new GPT-4 chat, you can click on the "Plugins" button and then go to the Plugin store.</p>

<p><img src="/assets/images/chatgpt-plugin-with-laravel/1-gpt-4.png" alt="GPT-4" /></p>

<p>From there, we go to the Plugin Store, and at the bottom, we click on <code>Develop your own plugin</code>.</p>

<p><img src="/assets/images/chatgpt-plugin-with-laravel/2-plugin-store.png" alt="Plugin Store" /></p>

<p>Here we are presented with a form to fill in the domain of our plugin. We input <code>localhost:8000</code> (if you changed the port, make sure to use the correct one).</p>

<p><img src="/assets/images/chatgpt-plugin-with-laravel/3-enter-website-domain.png" alt="Enter Website Domain" /></p>

<p>If everything went well, you will see the following screen:</p>

<p><img src="/assets/images/chatgpt-plugin-with-laravel/4-found-plugin.png" alt="Found Plugin" /></p>

<p><img src="/assets/images/chatgpt-plugin-with-laravel/5-new-plugin-selected.png" alt="New Plugin Selected" /></p>

<h2>Step 6 - Using the plugin</h2>

<p>Now that we have our plugin installed, we can use it in our chat.</p>

<p>ChatGPT will decide when to use your plugin depending on your description and OpenAPI specification,
so in the case of our browser plugin, simply giving a URL will do.</p>

<p>You might be wondering: why not just use <a href="https://www.webpilot.ai/" target="_blank">WebPilot</a>, the plugin that comes with ChatGPT?</p>

<p>The truth is that you can use WebPilot. The only difference is that
WebPilot uses a hosted server to browse. A server that can be rate-limited by websites, and you can't customize.</p>

<p>This is an example using WebPilot:
<img src="/assets/images/chatgpt-plugin-with-laravel/6-webpilot-ip.png" alt="WebPilot IP" /></p>

<p>And here is with our plugin:</p>

<p><img src="/assets/images/chatgpt-plugin-with-laravel/7-local-plugin-ip.png" alt="WebPilot IP" /></p>

<p>(The IP is the IP of my computer)</p>

<h2>Conclusion</h2>

<p>In this simple article, we saw how to create a plugin for ChatGPT using Laravel.</p>

<p>If you would like to see the whole code, you can find it <a href="https://github.com/juampi92/chatgpt-plugin-in-laravel" target="_blank">here: juampi92/chatgpt-plugin-in-laravel</a>. I added a few more features, like transforming the content into markdown, so there is less content to send to ChatGPT, and so hitting the characters limit less often.</p>
    ]]></content>
</entry>
            <entry>
    <id>https://barreto.jp/blog/grouping-routes/</id>
    <link type="text/html" rel="alternate" href="https://barreto.jp/blog/grouping-routes/" />
    <title>When and How to Group Routes in Laravel</title>
    <published>2023-02-27T00:00:00+00:00</published>
    <updated>2023-02-27T00:00:00+00:00</updated>
    <author>
        <name>Juan Pablo Barreto</name>
    </author>
    <summary type="html">This article discusses the problem of route file organization in Laravel applications and presents an alternative approach to route grouping that makes searching for paths easier and more efficient. It also covers the trade-offs and benefits of grouping routes and provides examples of when and how to group routes effectively.</summary>
    <content type="html"><![CDATA[
        <p>The aim of this article is to provide an explanation for why your route files should look less like this:</p>

<pre><code class="language-php">Route::prefix('playlists')-&gt;group(function () {
    Route::prefix('/{playlist}')-&gt;group(function () {
        Route::put('/', [PlaylistController::class, 'update']);
        Route::get('/', [PlaylistController::class, 'show']);

            Route::prefix('/tracks')-&gt;group(function () {
                Route::put('/', [PlaylistTrackController::class, 'update']);
                Route::post('/', [PlaylistTrackController::class, 'store']);
                Route::get('/', [PlaylistTrackController::class, 'index']);
                Route::delete('/', [PlaylistTrackController::class, 'delete']);
            });

        Route::prefix('/followers')-&gt;group(function () {
            Route::put('/', [PlaylistFollowerController::class, 'follow']);
            Route::delete('/', [PlaylistFollowerController::class, 'unfollow']);
        });
    });
});

Route::prefix('me')-&gt;group(function () {
    Route::get('/playlists', [MePlaylistController::class, 'index']);
});
</code></pre>

<p>And more like this:</p>

<pre><code class="language-php">Route::put('/playlists/{playlist}', [PlaylistController::class, 'update']);
Route::get('/playlists/{playlist}', [PlaylistController::class, 'show']);

Route::put('/playlists/{playlist}/tracks', [PlaylistTrackController::class, 'update']);
Route::post('/playlists/{playlist}/tracks', [PlaylistTrackController::class, 'store']);
Route::get('/playlists/{playlist}/tracks', [PlaylistTrackController::class, 'index']);
Route::delete('/playlists/{playlist}/tracks', [PlaylistTrackController::class, 'delete']);

Route::put('/playlists/{playlist}/followers', [PlaylistFollowerController::class, 'follow']);
Route::delete('/playlists/{playlist}/followers', [PlaylistFollowerController::class, 'unfollow']);

Route::get('/me/playlists', [MeFollowerController::class, 'index']);
</code></pre>

<h2>We search for paths</h2>

<p>If you use a text editor you are probably used to searching files using their name. Usually, the file name is enough, but what would you do if your files are all named “index”, “show”, “update”? Then you would have to narrow your search by adding the path of it.</p>

<p>The grouped approach makes searching for a path a complicated task and will make you scan multiple places before you find your match.</p>

<p>It is likely that your routes don’t look exactly like the first example, but they probably have some level of grouping. We will discuss when it is good to group and how to group consciously.</p>

<h2>Namespace grouping</h2>

<p>A popular approach to route grouping can be grouping by <strong>domain</strong>. You can take the example of this <a href="https://laravel-news.com/managing-routes" target="_blank">Laravel News article</a>.</p>

<p>If we adapt what the article mentions to our Spotify API example, we will have something like:</p>

<pre><code class="language-php">Route::prefix('playlists')-&gt;as('playlists:')-&gt;middleware(['auth:sanctum'])-&gt;group(
    base_path('routes/resources/playlists.php'),
);

Route::prefix('albums')-&gt;as('albums:')-&gt;middleware(['auth:sanctum'])-&gt;group(
    base_path('routes/resources/albums.php'),
);

Route::prefix('tracks')-&gt;as('tracks:')-&gt;middleware(['auth:sanctum'])-&gt;group(
    base_path('routes/resources/tracks.php'),
);
</code></pre>

<p>The confusion here comes when using prefixes to group the domain.</p>

<p>Our API has many ways to access the Tracks, and they all depend on the context from the previous menu:</p>

<pre><code class="language-php">/albums/{album}/tracks
/artists/{artist}/top-tracks
/tracks/{track}
/playlists/{playlist}/tracks
/...
</code></pre>

<p>The confusion to this comes when you have a <code>PlaylistTrackController</code>, does it belong to the Playlist domain or the Track domain? Will you search for it inside the <code>routes/resources/playlists.php</code> or <code>routes/resources/tracks.php</code>.</p>

<p>Personally, if the controller returns a Track response, then it shouldn't be part of the Playlist, even if the Playlist is the parent resource.</p>

<p>Whether it's by domain or by the root of the path, it will require your team to align on the way you group routes and resources.</p>

<h2>When to group</h2>

<p>There are some cases where grouping is useful and almost mandatory.</p>

<p><strong>Middleware</strong> is one such example, which can be easily overlooked but can have severe consequences. Grouping routes with shared middleware can declutter your definitions and prevent expensive mistakes.</p>

<p>Sometimes, we may need to group items based on <strong>technical considerations</strong> rather than domain-specific reasons. Examples of this include using the <code>/api</code> prefix, indicating the version of an API with <code>/v1</code>, or specifying the website's locale with <code>/{locale}</code>.</p>

<h2>Trade-offs</h2>

<p>One advantage of grouping paths is that it helps ensure consistent naming across all routes. If there's a typo in one path, it will likely affect all the others in the same group, making it easier to detect and fix the error compared to having a typo in a long list of 30 routes that share a common prefix.</p>

<p>These days, there are tools available in your IDE that can help you avoid typos, especially if you use English for your routes.</p>
    ]]></content>
</entry>
            <entry>
    <id>https://barreto.jp/blog/dev-only-config/</id>
    <link type="text/html" rel="alternate" href="https://barreto.jp/blog/dev-only-config/" />
    <title>Dev-only Laravel config</title>
    <published>2023-01-20T00:00:00+00:00</published>
    <updated>2023-01-20T00:00:00+00:00</updated>
    <author>
        <name>Juan Pablo Barreto</name>
    </author>
    <summary type="html">Bloated configuration files in Laravel applications is an issue, particularly when using third-party packages. This post suggests disabling developer-only configuration files on production to keep configuration files lightweight and optimized.</summary>
    <content type="html"><![CDATA[
        <h2>Introduction</h2>

<p>A key feature of Laravel is the way configuration files are handled. Configuration files are used to store and access a wide range of settings and parameters relevant for the application. As well as storing data like database connection strings or third-party service’s keys, they can also include application-specific data such as the title, authentication information, and other configuration settings.</p>

<h2>A Growing Problem</h2>

<p>Configuration files can easily become bloated and grow out of hand. This is especially true when working with third-party packages. Many third-party packages also use configuration files to configure their settings.</p>

<p>Unfortunately, some of these packages are only meant to run on a development or CI/CD environment, but they will still introduce big configuration files into every production request.</p>

<p>Packages like <a href="https://github.com/enlightn/enlightn/blob/master/config/enlightn.php" target="_blank">enlightn</a>, <a href="https://github.com/barryvdh/laravel-debugbar/blob/master/config/debugbar.php" target="_blank">debugbar</a>, <a href="https://github.com/laravel/telescope/blob/4.x/config/telescope.php" target="_blank">laravel telescope</a> are usually not used in production, yet they still contain a big configuration file that will be shipped to your production application.</p>

<h2>A Possible Solution</h2>

<p>My suggestion to handle this problem is to disable these developer-only configuration files on production. By ignoring certain configuration files, production can keep their configuration files lightweight and optimized.</p>

<p><code>config/debugbar.php</code></p>

<pre><code class="language-php">&lt;?php

if (env('APP_ENV', 'production') === 'production') {
    return [
        'enabled' =&gt; false,
    ];
}

return [

    /*
    |--------------------------------------------------------------------------
    | Debugbar Settings
</code></pre>

<h2>Disclaimer</h2>

<p>1) We can’t use <code>app()-&gt;environment(...)</code> inside config files because this method internally uses the config. Instead, we can use <code>env('APP_ENV')</code></p>

<p>2) In third-party packages we can’t return an empty array <code>[]</code> because Laravel will use the package’s default configuration if no local configuration is found. Having at least one property will override this behavior and still keep a slim configuration for production.</p>

<p>3) Having a different configuration for production can cause unexpected and untested results, so it is very important you are confident the code will fall back correctly.</p>
    ]]></content>
</entry>
            <entry>
    <id>https://barreto.jp/blog/reusable-sessions/</id>
    <link type="text/html" rel="alternate" href="https://barreto.jp/blog/reusable-sessions/" />
    <title>Reusable Sessions in Laravel</title>
    <published>2022-12-04T00:00:00+00:00</published>
    <updated>2022-12-04T00:00:00+00:00</updated>
    <author>
        <name>Juan Pablo Barreto</name>
    </author>
    <summary type="html">Sessions are an easy-to-use feature for a stateful application, but they usually get messy very quickly. Follow these steps to clean up your Sessions.</summary>
    <content type="html"><![CDATA[
        <p>Say you need to implement a simple shopping cart feature and you are planning on using the Session for it.</p>

<p>First, you create an endpoint to add a product and an amount:</p>

<pre><code class="language-php">$request-&gt;session()-&gt;push('cart', [
    'productId' =&gt; $product-&gt;id,
    'amount' =&gt; $request-&gt;amount,
]);
</code></pre>

<p>Then, to access it, you create the Cart endpoint to display all items:</p>

<pre><code class="language-php">$items = $request-&gt;session()-&gt;get('cart', []);
</code></pre>

<p>Finally, you allow flushing the session altogether:</p>

<pre><code class="language-php">$request-&gt;session()-&gt;forget('cart');
</code></pre>

<p>This implementation is decent enough, although we repeat <code>'cart'</code> too often. To avoid accidentally introducing a typo, we can refactor it into a constant.</p>

<p>The client sees this and is happy about it. However, after using the feature, they realize they would like to see product recommendations based on what is in the cart.</p>

<p>To achieve this, we simply need to use the <code>RecommendationService</code> that takes an array of product IDs.</p>

<pre><code class="language-php">$items = $request-&gt;session()-&gt;get('cart', []);
$productIds = Arr::pluck($items, 'productId');

$recommendationService-&gt;recommend($productIds);
</code></pre>

<p>This approach doesn't scale. You will have to repeat every section that uses the session. Can you imagine how it would be to update the structure or the way we add products?</p>

<h2>Repository pattern</h2>

<p>This is where the Repository pattern comes into play. They abstract access to the data store and only provide access to business methods.</p>

<p>Let's first imagine the methods we would like to have in this implementation.</p>

<p>A method to add a product.</p>

<pre><code class="language-php">public function addItem(Product $product, int $amount): void;
</code></pre>

<p>A method to get all items.</p>

<pre><code class="language-php">/**
 * @return array&lt;array{productId: int, amount: int}&gt;
 */
public function getItems(): array;
</code></pre>

<p>A method to flush all items.</p>

<pre><code class="language-php">public function flush(): void;
</code></pre>

<p>And finally, a method to retrieve all products.</p>

<pre><code class="language-php">/**
 * @return array&lt;int&gt;
 */
public function getProductIds(): array;
</code></pre>

<p>Perfect!</p>

<p>Now the implementation can write itself:</p>

<pre><code class="language-php">&lt;?php

namespace App\Http\Session;

final class ShoppingCartSession
{
    private const KEY = 'cart';

    public function __construct(
        private readonly Store $store,
    ) {}

    public function addProduct(Product $product, int $amount): void
    {
        $this-&gt;store-&gt;push(self::KEY, [
            'productId' =&gt; $product-&gt;id,
            'amount' =&gt; $amount,
        ]);
    }

    /**
     * @return array&lt;array{productId: int, amount: int}&gt;
     */
    public function getItems(): array
    {
        return $this-&gt;store-&gt;get(self::KEY, []);
    }

    /**
     * @return array&lt;int&gt;
     */
    public function getProductIds(): array
    {
        return Arr::pluck($this-&gt;getItems(), 'productId');
    }

    public function flush(): void
    {
        return $this-&gt;store-&gt;forget(self::KEY);
    }
}
</code></pre>

<p>And the controller would look something like this:</p>

<pre><code class="language-php">public function store(Request $request, Product $product, ShoppingCartSession $cart)
{
    $cart-&gt;addProduct($product, $request-&gt;amount);
    // ...
</code></pre>

<hr />

<p>Some key features of using a class are:</p>

<ul>
<li>The dependencies are injected. There is no need to worry about facades or requests.</li>
<li>You expose the methods that will be used by the controllers. As a consequence, you hide the underlying implementation, preventing invalid data from being inserted.</li>
<li>You never expose the key.</li>
</ul>

<p>Even though in this example we store the same array-shape structure as we read, we could easily use a ValueObject, and refactor the getItems method to return an array of ProductItem value object instead.</p>

<p>Now, where to locate these classes? I personally suggest <code>app/Http/Session</code>. Although they are a storage, the Session is an http-dependent storage (you can’t access the session inside a Command, for instance).</p>

<p><u>Bonus track</u>: As a next level exercise, I would like to advise to take a look at this <a href="https://gist.github.com/juampi92/487dd66c5b2507679dd4c76863e6c01c" target="_blank">KeyedSession implementation</a> to avoid repeating the key every time.</p>
    ]]></content>
</entry>
            <entry>
    <id>https://barreto.jp/blog/interviewing-conflict/</id>
    <link type="text/html" rel="alternate" href="https://barreto.jp/blog/interviewing-conflict/" />
    <title>Interviewing Conflict</title>
    <published>2022-11-30T00:00:00+00:00</published>
    <updated>2022-11-30T00:00:00+00:00</updated>
    <author>
        <name>Juan Pablo Barreto</name>
    </author>
    <summary type="html">It is very common to start a technical interview by giving a coding challenge to the candidate and observing their problem-solving skills. Although technical skills are important, most developers face many soft-skill problems on a daily basis.</summary>
    <content type="html"><![CDATA[
        <h2>Intro</h2>

<p>It is very common to start a technical interview by giving a coding challenge to the candidate and observing their problem-solving skills.</p>

<p>Although technical skills are important, most developers face many soft-skill problems on a daily basis. From reviewing pull requests to making RFCs, developers have to exchange ideas, negotiate, and deal with opinions from different cultures.</p>

<p>It is the aim of this article to present interview strategies that can be used to detect conflicting candidates before hiring them.</p>

<p><img src="/assets/images/2-interviewing-conflict.jpg" alt="Interviewing Conflict Preview" />
Photo by <a href="https://unsplash.com/@hungriadb" target="_blank">Diogo Hungria</a> on Unsplash</p>

<h2>The price of pride</h2>

<p>Developers with experience tend to have big egos.
Pride can make people focus on who is right or wrong, instead of working on what is right for the codebase.
These long discussions tend to be very exhausting for everyone involved, lowering the morale of the developers involved, and preventing them from ever arguing with them again.</p>

<h2>Interviewing for Conflicts</h2>

<p>Would it be helpful to be able to identify candidates who will not integrate well with the rest of the team during the interview process?</p>

<p><a href="https://www.google.com/search?q=interviewing+conflict" target="_blank">It is common practice</a> in the interview process to explicitly ask the candidate how would they deal with conflict. They are usually asked to describe a situation where they had conflicts with a colleague, and how did they manage to solve the problem. Although the intention is good, this is a theoretical question, and the practice can be far from ideal.</p>

<p>A practice I adopted while interviewing is to focus on generating controlled conflicts and observing how the candidate reacts. Are they immediately defensive or are they considering new ideas? Are they asking questions to understand it better, or are they fixed in their initial solution? Can they recognize the pain points in their solution? Can they comprehend the tradeoffs from both solutions and make an informed decision considering both ideas?</p>

<p>This practice is otherwise known as <a href="https://en.wiktionary.org/wiki/devil%27s_advocate#Noun" target="_blank">devil’s advocate</a>, and it is not only useful to test the strength of a proposal, but also to test how someone reacts to a difference of opinion from their own.</p>

<h2>Do it yourself</h2>

<p>This technique works only if you are going against an idea of their own. It helps if previous to the interview you reviewed a take-home test. Before the interview, we look for opinionated decisions that might have trade-offs with other approaches: are they using a specific pattern? Are they separating their responsibilities correctly? Could they be more decoupled?</p>

<p>Once you’ve recognized these potential points, you should formulate a question that challenges the candidate to find weaknesses in them. You can achieve this by pointing out an edge case or proposing hypothetical scenarios where the solution doesn’t scale correctly.</p>

<p>You should show that you don’t agree with their implementation, but instead of saying why you don’t, you should describe a situation that illustrates its flaws.</p>

<p>The exercise is for them to reflect on their solution, understand the weakness you describe, and propose an alternative that will contemplate both, even if they don’t fully agree. Here, the goal is to get them to analyze the trade-offs of both solutions and engage in a productive discussion.</p>

<p>It sounds simple, but you would be surprised at how many people act defensively against their code and have a hard time letting go of their own implementation.</p>

<h2>Conclusion</h2>

<p>Overall, what makes a high-performing team is not only having superhero developers, but having a healthy dynamic between team members.</p>

<p>Team members who can communicate ideas without getting personal and collaborate towards a greater codebase will prove more valuable in the long run.</p>
    ]]></content>
</entry>
            <entry>
    <id>https://barreto.jp/blog/seo-testing/</id>
    <link type="text/html" rel="alternate" href="https://barreto.jp/blog/seo-testing/" />
    <title>Testing your SEO with PHP &amp; Pest</title>
    <published>2022-09-01T00:00:00+00:00</published>
    <updated>2022-09-01T00:00:00+00:00</updated>
    <author>
        <name>Juan Pablo Barreto</name>
    </author>
    <summary type="html">Just like any other test suite, SEO tests will give your team confidence in your HTML structure and will prevent expensive mistakes.</summary>
    <content type="html"><![CDATA[
        <p>SEO testing is a practice that can prevent unwanted changes in search engines.
If you are interested in knowing why, in this <a href="https://medium.com/studocu-techblog/the-importance-of-testing-your-seo-9056e8f47ef7" target="_blank">medium article</a> I explain the importance of it, and the possible consequences of not doing so.</p>

<p>This article will focus on testing a PHP project using the utility package <a href="https://github.com/juampi92/test-seo" target="_blank">test-seo</a>.</p>

<blockquote>
  <p>Note: The examples in this post are made using <a href="https://pestphp.com/" target="_blank">Pest</a> with Laravel, but none of these are required for the package to work.</p>
</blockquote>

<p><img src="/assets/images/1-test-seo-code-preview.jpg" alt="TestSEO Code Preview" /></p>

<h2>Setup</h2>

<p>To install the package, run:</p>

<pre><code class="language-bash">composer require juampi92/test-seo --dev
</code></pre>

<blockquote>
  <p>It is assumed PHPUnit and Pest are already installed in your project.</p>
</blockquote>

<h2>Testing the landing page</h2>

<p>The first step to a successful landing page, is a 200 status code, so we'll start with that.</p>

<pre><code class="language-php">test('landing page SEO tags', function () {
    $response = get('/')-&gt;assertStatus(200);
});
</code></pre>

<p>To use this package, you will have to instantiate the TestSEO using the HTML response:</p>

<pre><code class="language-php">test('landing page SEO tags', function () {
    $response = get('/')-&gt;assertStatus(200);

    // And now we generate the TestSEO object with the html response:
    $seo = new TestSEO($response-&gt;getContent());
});
</code></pre>

<p>For the landing page, we would like to test that the title is <code>My Blog</code>, the canonical url is self-referencing, and the robots are correct.</p>

<pre><code class="language-php">test('landing page SEO tags', function () {
    // ...
    $seo = new TestSEO($response-&gt;getContent());

    expect($seo-&gt;data)
        -&gt;title()-&gt;toBe('My Blog')
        -&gt;canonical()-&gt;toEqual(route('home'))
        -&gt;robots()-&gt;index()-&gt;toBeTrue()
        -&gt;robots()-&gt;follow()-&gt;toBeTrue();
});
</code></pre>

<h2>Snapshot testing</h2>

<p>To do snapshot testing, first we need to install spatie's snapshot package:</p>

<pre><code class="language-bash">composer require spatie/pest-plugin-snapshots --dev
</code></pre>

<p>Now we only have to assert that the TestSEO matches the snapshot.</p>

<pre><code class="language-php">use function Spatie\Snapshots\{assertMatchesJsonSnapshot};

test('landing page SEO tags', function () {
    // ...
    $seo = new TestSEO($response-&gt;getContent());

    assertMatchesJsonSnapshot(json_encode($seo));
});
</code></pre>

<p>The TestSEO implements the <a href="https://www.php.net/manual/en/jsonserializable.jsonserialize.php" target="_blank">jsonSerialize()</a> method to be compared against the JSON snapshot.</p>

<p>By default, it will use a simple structure serializer that includes the title, description, robots, etc. If you would like to make your custom Serializer, you can follow the following steps:</p>

<pre><code class="language-php">use Juampi92\TestSEO\SEOData;
use Juampi92\TestSEO\SnapshotFormatters\SnapshotSerializer;

class MySerializer implements SnapshotSerializer
{
    public function toArray(SEOData $data): array
    {
        return [
            'title' =&gt; $data-&gt;title(),
            'description' =&gt; $data-&gt;description(),
            'robots' =&gt; (string) $data-&gt;robots(),
            'canonical' =&gt; $data-&gt;canonical(),
            'pagination' =&gt; [
                'prev' =&gt; $data-&gt;prev(),
                'next' =&gt; $data-&gt;next(),
            ],
        ];
    }
}
</code></pre>

<p>To use this formatter, you simply have to pass it as TestSEO's second parameter:</p>

<pre><code class="language-php">test('landing page SEO tags', function () {
    // ...
    $seo = new TestSEO($response-&gt;getContent(), new MySerializer());

    $json = json_encode($seo);
});
</code></pre>

<h3>What about seeded data?</h3>

<p>When testing dynamic pages, you will have to seed data in order to test the page. Seeded data usually uses random attributes which will make every seed unique. Generating unique attributes each time will never match the previous attribute stored in the snapshot.</p>

<p><strong>How do we solve this problem?</strong> We don't fake.</p>

<p>When testing SEO pages, we will control our attributes. If we want to test how a title gets cropped in the <code>&lt;title/&gt;</code> tag, we will seed always the same long title.</p>

<pre><code class="language-php">test('article page SEO tags', function () {
    $article = Article::factory()-&gt;create([
        'title' =&gt; 'This is a very long title, and I would like to see it cropped',
    ]);

    $response = get(RouteHelper::article($article))-&gt;assertStatus(200);
    $seo = new TestSEO($response-&gt;getContent(), new MySerializer());

    expect($seo-&gt;data)
        -&gt;title()-&gt;toBe('This is a very long title, and I would like to see it... - My Blog');

    $json = json_encode($seo);
    // {
    //    "title": "This is a very long title, and I would like to see it... - My Blog",
    //    ...
    // }
});
</code></pre>

<p>Now we have a new issue: unique IDs. It is very likely that you will get different IDs on each run, and if you use IDs in URLs, the snapshots won't match.</p>

<p>The easiest solution to his problem is to replace the unique IDs with a generic placeholder, and that's what the default serializer is doing.</p>

<pre><code class="language-bash">/article/this-is-a-very-long-title/15
</code></pre>

<p>Gets replaced to:</p>

<pre><code class="language-bash">/article/this-is-a-very-long-title/{id}
</code></pre>

<p>Now, any seeded article will match the snapshot.</p>

<blockquote>
  <p>In the case where replacing numbers for {id} is not sufficient, snapshot testing may not be the best approach.</p>
</blockquote>

<h2>Most common assertions</h2>

<p>Search engines have made it clear that breaking certain rules can lead to a negative ranking.
In order to test them easier, this package includes assertions for some of these rules:</p>

<h3>Never have more than one H1</h3>

<p>Search engines pay a lot of attention to the H1, and that's also why they do not like it when you use more than one per page.
This package comes with a method:</p>

<pre><code class="language-php">$seo-&gt;assertThereIsOnlyOneH1();
</code></pre>

<h3>All images have <code>alt</code> attribute</h3>

<p>This is also a good SEO practice: Images should have an "alternative" tag with a meaningful text.</p>

<pre><code class="language-php">$seo-&gt;assertAllImagesHaveAltText();
</code></pre>

<h2>Conclusion</h2>

<p>If your website relies on search engines, you will do whatever you can to please them, and that includes not messing up.
Having a decent SEO coverage can give your team the confidence to refactor pages and now worry about modifying the SEO structure by accident.</p>

<p>Checkout the package to see all its features, and Pull-Request are welcome!</p>

<p><a href="https://github.com/juampi92/test-seo#test-seo" target="_blank">https://github.com/juampi92/test-seo</a></p>
    ]]></content>
</entry>
    </feed>
